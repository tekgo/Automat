<!DOCTYPE html>
<html>
<head>
	<title>Automat Testing Ground</title>
<script>

	class Automat {
		constructor(size, comparatorFunc) {
			this.size = size;
			this.data = new Uint32Array(size * size);
			this.nullData = 0xFF808080;
			this.comparatorFunc = comparatorFunc;

			this.randomize();
		}

		getValue(x,y) {
			let size = this.size;
			if (x < 0 || y < 0 || x >= size || y >= size) {
				return this.data[((x + size) % size) + (((y + size) % size) * size)]
			}
			return this.data[x + (y * size)];
		}

		setValue(x,y, value) {
			let size = this.size
			if (x < 0 || y < 0 || x >= this.size || y >= this.size) {
				return this.data[((x + size) % size) + (((y + size) % size) * size)] = value;
			}
			return this.data[x + (y * size)] = value;
		}

		tick() {
			let size = this.size;
			let newData = new Uint32Array(size * size);

			for (var i = 0; i < (size * size); i++) {
				let x = i % size;
				let y = Math.floor(i / size);
				newData[i] = this.comparator(x,y,this.getKernel(x,y));
			}
			this.data = newData
		}

		getKernel(x,y) {
			let values = [];

			for (var i = y - 1; i <= y + 1; i++) {
				for (var j = x - 1; j <= x + 1; j++) {
					values.push(this.getValue(j,i));
				}
			}

			return values;
		}

		comparator(x, y, kernel) {
			return this.comparatorFunc(x, y, kernel);
		}

		render() {
			let size = this.size;
			let imageData = new ImageData(size, size);
			let u32 = new Uint32Array(imageData.data.buffer)
			for (var i = 0; i < (size * size); i++) {
				u32[i] = this.data[i];
			}

			return imageData
		}

		randomize() {
			let size = this.size;
			for (var i = 0; i < (size * size); i++) {
				this.data[i] = Automat.fromRGB([Math.floor(Math.random() * 256),Math.floor(Math.random() * 256),Math.floor(Math.random() * 256)]);
			}
		}

		static toRGB(color) {
			return [(color >> 0) & 0xff, (color >> 8) & 0xff, (color >> 16) & 0xff];
		}

		static fromRGB(color) {
			return (((color[0] & 0xff)) |
			((color[1] & 0xff) << 8) |
			((color[2] & 0xff) << 16) |
			(0xff) << 24);
		}

		static greyScale(color) {
			let rgb = this.toRGB(color);
			let avg = (rgb[0] + rgb[1] + rgb[2]) / 3;
			u32[i] = this.fromRGB([avg,avg,avg]);
		}
	}

	class Comparator {

		static colorFire(x, y, kernel) {
			let values = kernel.map( c => Automat.toRGB(c));

			let value = values[4];
			let newValue = value;

			let idxs = [x + y, y + x + 1, x + y + 2];

			for (var j = 0; j < idxs.length; j++) {
				let i = idxs[j] % 3;
				let avg = Math.floor((values[0][i] + values[1][i] + values[2][i] + values[3][i] + values[5][i] + values[6][i] + values[7][i] + values[8][i]) / 8);

				let next = (i + 1) % 3;

				let diff = value[i] - avg;

				if (diff == 0) {
					newValue[i] = values[i][i];
				}
				else if(Math.abs(diff) > 48) {
					newValue = values[i+6];
				}
				if (value[i] < avg) {
					newValue[next]++;
				}
				else if (value[i] > avg) {
					newValue[next]--;
				}
			}

			return Automat.fromRGB(newValue);
		}

		static colorFall(x, y, kernel) {
			let values = kernel.map( c => Automat.toRGB(c));

			let value = values[4];
			let newValue = value;

			let idxs = [x + y, y + x + 1, x + y + 2];

			for (var j = 0; j < idxs.length; j++) {
				let i = idxs[j] % 3;
				let avg = Math.floor((values[0][i] + values[1][i] + values[2][i] + values[3][i] + values[5][i] + values[6][i] + values[7][i] + values[8][i]) / 8);

				let next = (i + 1) % 3;

				let diff = value[i] - avg;

				if (diff == 0) {
					newValue[i] = values[i][i];
				}
				else if(Math.abs(diff) < 48) {
					newValue = values[i];
				}
				if (value[i] < avg) {
					newValue[next]++;
				}
				else if (value[i] > avg) {
					newValue[next]--;
				}
			}

			return Automat.fromRGB(newValue);
		}

		static RGBToHSV(rgb) {
			const r = rgb[0]
			const g = rgb[1];
			const b = rgb[2];

			let max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				d = max - min,
				h,
				s = (max === 0 ? 0 : d / max),
				v = max / 255;

			switch (max) {
				case min:
					h = 0;
					break;
				case r:
					h = (g - b) + d * (g < b ? 6 : 0);
					h /= 6 * d;
					break;
				case g:
					h = (b - r) + d * 2;
					h /= 6 * d;
					break;
				case b:
					h = (r - g) + d * 4;
					h /= 6 * d;
					break;
			}

			return Array(h, s, v);
		}

		static HSVToRGB(arr) {
			const h = arr[0];
			const s = arr[1];
			const v = arr[2];
			let r, g, b, i, f, p, q, t;
			i = ~~(h * 6);
			f = h * 6 - i;
			p = v * (1 - s);
			q = v * (1 - f * s);
			t = v * (1 - (1 - f) * s);
			switch (i % 6) {
				case 0:
					r = v, g = t, b = p;
					break;
				case 1:
					r = q, g = v, b = p;
					break;
				case 2:
					r = p, g = v, b = t;
					break;
				case 3:
					r = p, g = q, b = v;
					break;
				case 4:
					r = t, g = p, b = v;
					break;
				case 5:
					r = v, g = p, b = q;
					break;
			}
			return Array(r * 255, g * 255, b * 255);
		}

		static colorSwiper(x, y, kernel, hueRate) {
			let values = kernel.map( c => Comparator.RGBToHSV(Automat.toRGB(c)));
			let value = values[4];
			let newValue = value;

			let avgSat = (values.reduce((accumulator, currentValue) => accumulator + currentValue[1], 0) - value[1]) / 8;
			let avgBright = (values.reduce((accumulator, currentValue) => accumulator + currentValue[2], 0) - value[2]) / 8;

			let dir = (Math.floor(value[0] * 8)) % 8;
			let next = 0;
			
			switch (dir) {
				case 0:
					next = 1;
					break;
				case 1:
					next = 2;
					break;
				case 2:
					next = 5;
					break;
				case 3:
					next = 8;
					break;
				case 4:
					next = 7;
					break;
				case 5:
					next = 6;
					break;
				case 6:
					next = 3;
					break;
				case 7:
					next = 0;
					break;
			}

			if (avgBright < 0.4) {
				newValue[2]+= 0.01;
			}
			else if (avgBright > 0.7) {
				newValue[2]-= 0.01;
			}
			else {
				newValue= values[next];
			}

			if (avgSat < 0.4) {
				newValue[1]+= 0.01;
			}
			else if (avgSat > 0.7) {
				newValue[1]-= 0.01;
			}
			else {
				newValue= values[next];
			}

			newValue[0] += hueRate;


			return Automat.fromRGB(Comparator.HSVToRGB(newValue));
		}

		static colorSwipe(x, y, kernel) {
			return Comparator.colorSwiper(x, y, kernel, 1 / 128);
		}

		static colorWeaver(x, y, kernel) {
			return Comparator.colorSwiper(x, y, kernel, 1 / 512);
		}
	}

	let scaleImageData = function(imgDat1, scale) {
		var imgDat2 = new ImageData(imgDat1.width * scale, imgDat1.height * scale);
		var pix1 = new Uint32Array(imgDat1.data.buffer);
		var pix2 = new Uint32Array(imgDat2.data.buffer);
		var canvasWidth1 = imgDat1.width;
		var canvasWidth2 = imgDat2.width;
		for (let x = 0; x < imgDat1.width; ++x) {
			for (let y = 0; y < imgDat1.height; ++y) {
				var idx = y * imgDat1.width + x;
				for (let i = 0; i < scale; ++i) {
					for (let j = 0; j < scale; ++j) {
						pix2[(((y * scale) + j) * imgDat2.width) + (x * scale) + i] = pix1[idx];
					}
				}
			}
		}
		return imgDat2
	}

	var currentAutomat = null;

	function setup(func) {
		currentAutomat = null;
		currentAutomat = new Automat(256, func);
	}

	function init() {
		setup(Comparator.colorSwipe);
		render();

	}

	function render() {
		currentAutomat.tick();
		let data = currentAutomat.render();

		let canvas = document.getElementById("canvas");
		let ctx = canvas.getContext('2d');
		ctx.putImageData(scaleImageData(data,2), 0, 0);
		window.requestAnimationFrame(render);
	}

</script>

</head>
<body onload="init();">

	<canvas id="canvas" width=512 height=512 > </canvas><br/>
	<button onclick="setup(Comparator.colorWeaver)">ColorWeaver</button>
	<button onclick="setup(Comparator.colorSwipe)">ColorSwipe</button>
	<button onclick="setup(Comparator.colorFire)">ColorFire</button>
	<button onclick="setup(Comparator.colorFall)">ColorFall</button>

</body>
</html>